{"version":3,"sources":["../src/routes/ReduxAsyncConnect.js"],"names":["ReduxAsyncConnect","state","previousLocation","configure","trickleSpeed","nextProps","props","history","location","routes","store","helpers","navigated","start","setState","pathname","components","match","params","__CLIENT__","done","children","propTypes","node","isRequired","objectOf","any"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AACA;;;;AACA;;AACA;;AACA;;;;AACA;;;;;;IAGqBA,iB;;;;;;;;;;;;;;kOAOnBC,K,GAAQ;AACNC,wBAAkB;AADZ,K;;;;;yCAIa;AACnB,0BAAUC,SAAV,CAAoB,EAAEC,cAAc,GAAhB,EAApB;AACD;;;;4GAE+BC,S;;;;;;;yBAG1B,KAAKC,K,EADPC,O,UAAAA,O,EAASC,Q,UAAAA,Q,EAAUC,M,UAAAA,M,EAAQC,K,UAAAA,K,EAAOC,O,UAAAA,O;AAE9BC,yB,GAAYP,UAAUG,QAAV,KAAuBA,Q;;qBAErCI,S;;;;;AACF;AACA,oCAAUC,KAAV;AACA,qBAAKC,QAAL,CAAc,EAAEZ,kBAAkBM,QAApB,EAAd;;AAEA;;uBAC4C,gCAAiBC,MAAjB,EAAyBJ,UAAUG,QAAV,CAAmBO,QAA5C,C;;;;AAApCC,0B,SAAAA,U;AAAYC,qB,SAAAA,K;AAAOC,sB,SAAAA,M;;uBAErB,qBAAQ,OAAR,EAAiBF,UAAjB,6BACDL,OADC;AAEJD,8BAFI;AAGJO,8BAHI;AAIJC,gCAJI;AAKJX,kCALI;AAMJC,4BAAUH,UAAUG;AANhB,mB;;;qBAQFW,U;;;;;;uBACI,qBAAQ,OAAR,EAAiBH,UAAjB,6BACDL,OADC;AAEJD,8BAFI;AAGJO,8BAHI;AAIJV,kCAJI;AAKJC,4BAAUH,UAAUG;AALhB,mB;;;;AASR;AACA,qBAAKM,QAAL,CAAc,EAAEZ,kBAAkB,IAApB,EAAd;AACA,oCAAUkB,IAAV;;;;;;;;;;;;;;;;;;6BAIK;AAAA,oBACwB,KAAKd,KAD7B;AAAA,UACCe,QADD,WACCA,QADD;AAAA,UACWb,QADX,WACWA,QADX;AAAA,UAECN,gBAFD,GAEsB,KAAKD,KAF3B,CAECC,gBAFD;;AAIP;AACA;;AACA,aAAO,oDAAO,UAAUA,oBAAoBM,QAArC,EAA+C,QAAQ;AAAA,iBAAMa,QAAN;AAAA,SAAvD,GAAP;AACD;;;6BA3DMC,S,GAAY;AACjBD,YAAU,oBAAUE,IAAV,CAAeC,UADR;AAEjBjB,WAAS,oBAAUkB,QAAV,CAAmB,oBAAUC,GAA7B,EAAkCF,UAF1B;AAGjBhB,YAAU,oBAAUiB,QAAV,CAAmB,oBAAUC,GAA7B,EAAkCF;AAH3B,C;;kBADAxB,iB","file":"ReduxAsyncConnect.js","sourcesContent":["import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { withRouter, Route } from 'react-router';\nimport { trigger } from 'redial';\nimport NProgress from 'nprogress';\nimport asyncMatchRoutes from './asyncMatchRoutes';\n\n@withRouter\nexport default class ReduxAsyncConnect extends Component {\n  static propTypes = {\n    children: PropTypes.node.isRequired,\n    history: PropTypes.objectOf(PropTypes.any).isRequired,\n    location: PropTypes.objectOf(PropTypes.any).isRequired\n  };\n\n  state = {\n    previousLocation: null\n  };\n\n  componentWillMount() {\n    NProgress.configure({ trickleSpeed: 200 });\n  }\n\n  async componentWillReceiveProps(nextProps) {\n    const {\n      history, location, routes, store, helpers\n    } = this.props;\n    const navigated = nextProps.location !== location;\n\n    if (navigated) {\n      // save the location so we can render the old screen\n      NProgress.start();\n      this.setState({ previousLocation: location });\n\n      // load data while the old screen remains\n      const { components, match, params } = await asyncMatchRoutes(routes, nextProps.location.pathname);\n\n      await trigger('fetch', components, {\n        ...helpers,\n        store,\n        match,\n        params,\n        history,\n        location: nextProps.location\n      });\n      if (__CLIENT__) {\n        await trigger('defer', components, {\n          ...helpers,\n          store,\n          match,\n          history,\n          location: nextProps.location\n        });\n      }\n\n      // clear previousLocation so the next screen renders\n      this.setState({ previousLocation: null });\n      NProgress.done();\n    }\n  }\n\n  render() {\n    const { children, location } = this.props;\n    const { previousLocation } = this.state;\n\n    // use a controlled <Route> to trick all descendants into\n    // rendering the old location\n    return <Route location={previousLocation || location} render={() => children} />;\n  }\n}\n\n\n"]}