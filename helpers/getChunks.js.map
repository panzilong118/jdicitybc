{"version":3,"sources":["../src/helpers/getChunks.js"],"names":["chunksPath","timeout","waitWatchFile","path","onChange","err","stats","Error","chunksStats","parse","chunksStatsJson","waitChunks","getChunks","watch","loaded","timeleft","resolve","reject","access","constants","R_OK","readFile","err2","data","__DEVELOPMENT__","watcher","eventType","setTimeout","close","code","json","JSON","e"],"mappings":"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","file":"getChunks.js","sourcesContent":["import fs from 'fs';\r\n\r\nlet chunksStats = [];\r\n\r\nexport default function getChunks() {\r\n  return chunksStats;\r\n}\r\n\r\nexport function waitWatchFile({ path, onChange, timeout = 60000 } = {}) {\r\n  function watch(loaded, timeleft) {\r\n    return new Promise((resolve, reject) => {\r\n      if (timeleft < 0) {\r\n        loaded = true;\r\n        return reject(new Error(`waitFile: timeout (${timeout}ms): ${path}`));\r\n      }\r\n\r\n      // Simple first read for production\r\n      if (!loaded) {\r\n        fs.access(path, fs.constants.R_OK, err => {\r\n          if (!err && !loaded) {\r\n            fs.readFile(path, 'utf8', (err2, data) => {\r\n              if (err2) return reject(err2);\r\n              loaded = true;\r\n              resolve(data);\r\n            });\r\n          }\r\n        });\r\n      }\r\n\r\n      if (!__DEVELOPMENT__) {\r\n        return;\r\n      }\r\n\r\n      try {\r\n        const watcher = fs.watch(path, 'utf8', eventType => {\r\n          if (eventType !== 'change') return;\r\n          fs.readFile(path, 'utf8', (err2, data) => {\r\n            if (err2) return onChange(err2);\r\n            loaded = true;\r\n            onChange(null, data);\r\n          });\r\n        });\r\n\r\n        setTimeout(() => {\r\n          watcher.close();\r\n          if (!loaded) {\r\n            loaded = true;\r\n            reject(new Error(`waitFile: timeout (${timeout}ms): ${path}`));\r\n          }\r\n        }, timeleft);\r\n      } catch (err) {\r\n        if (err.code === 'ENOENT') {\r\n          return setTimeout(() => resolve(watch(loaded, timeleft - 100)), 100);\r\n        }\r\n        loaded = true;\r\n        reject(err);\r\n      }\r\n    });\r\n  }\r\n\r\n  return watch(false, timeout);\r\n}\r\n\r\nfunction parse(json) {\r\n  try {\r\n    return JSON.parse(json);\r\n  } catch (e) {\r\n    return chunksStats;\r\n  }\r\n}\r\n\r\nexport async function waitChunks(chunksPath, timeout) {\r\n  const chunksStatsJson = await waitWatchFile({\r\n    path: chunksPath,\r\n    onChange(err, stats) {\r\n      if (err) {\r\n        throw new Error('Unable to load chunks');\r\n      }\r\n      chunksStats = parse(stats);\r\n    },\r\n    timeout\r\n  });\r\n\r\n  chunksStats = parse(chunksStatsJson);\r\n\r\n  return chunksStats;\r\n}\r\n"]}